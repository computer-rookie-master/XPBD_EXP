# GJK 算法原理（Narrow Phase Collision Detection）

GJK 算法（Gilbert-Johnson-Keerthi 算法）是一种高效的碰撞检测方法，特别适合处理凸形状之间的碰撞检测（如球体、凸多面体）。它广泛应用于物理引擎（如 Bullet、PhysX），因其高效性和扩展性而受到欢迎。以下是其原理的详细讲解。

## 1. 核心思想：Minkowski 差

### 定义
GJK 算法的核心基于 **Minkowski 差**（Minkowski Difference）。Minkowski 差将两个形状 \( A \) 和 \( B \) 之间的碰撞问题转化为判断原点是否位于一个特定形状内部的问题。

- **Minkowski 差公式**：
  $$
  A - B = \{ \mathbf{a} - \mathbf{b} \mid \mathbf{a} \in A, \mathbf{b} \in B \}
  $$
  其中，\( A - B \) 是 \( A \) 中每个点 \(\mathbf{a}\) 减去 \( B \) 中每个点 \(\mathbf{b}\) 的差向量的集合。

- **碰撞判定的等价性**：
  两个形状 \( A \) 和 \( B \) 相交（即存在某个点同时属于 \( A \) 和 \( B \)）的条件等价于原点 \(\mathbf{0}\) 属于 \( A - B \)：
  $$
  \text{若 } A \cap B \neq \emptyset \text{，则 } \mathbf{0} \in A - B
  $$
  原因在于，如果 \( A \) 和 \( B \) 相交，则存在 \(\mathbf{a} \in A\) 和 \(\mathbf{b} \in B\)，使得 \(\mathbf{a} = \mathbf{b}\)，从而 \(\mathbf{a} - \mathbf{b} = \mathbf{0}\)。

## 2. 支撑函数（Support Function）

GJK 算法依赖 **支撑函数** 来操作凸形状，而无需显式计算整个 Minkowski 差（因为这在高维或复杂形状下计算量巨大）。

- **定义**：
  对于一个凸形状 \( S \) 和一个方向向量 \(\mathbf{d}\)，支撑函数 \( s_S(\mathbf{d}) \) 返回形状 \( S \) 在方向 \(\mathbf{d}\) 上最远的点：
  $$
  s_S(\mathbf{d}) = \arg\max_{\mathbf{x} \in S} (\mathbf{x} \cdot \mathbf{d})
  $$
  即找到边界上沿 \(\mathbf{d}\) 方向最远的点。

- **Minkowski 差的支撑函数**：
  对于 Minkowski 差 \( A - B \)，其支撑函数可以通过 \( A \) 和 \( B \) 的支撑函数直接计算：
  $$
  s_{A-B}(\mathbf{d}) = s_A(\mathbf{d}) - s_B(-\mathbf{d})
  $$
  即在方向 \(\mathbf{d}\) 上，\( A - B \) 的最远点是 \( A \) 在 \(\mathbf{d}\) 方向上的最远点减去 \( B \) 在 \(-\mathbf{d}\) 方向上的最远点。

## 3. 单纯形（Simplex）

GJK 算法通过构建一个 **单纯形** 来判断原点是否在 \( A - B \) 中。单纯形是几何中的一个概念：
- 在 2D 中，单纯形可以是点（0-simplex）、线段（1-simplex）、三角形（2-simplex）。
- 在 3D 中，单纯形可以是点（0-simplex）、线段（1-simplex）、三角形（2-simplex）、四面体（3-simplex）。

GJK 算法的目标是迭代构建一个单纯形，逐步逼近 \( A - B \) 中的点，直到确定原点是否在 \( A - B \) 内。

## 4. GJK 算法步骤

GJK 算法是一个迭代过程，逐步构建单纯形并判断原点是否在其内部。以下是具体步骤：

### 1. 初始化
- 选择一个初始方向 \(\mathbf{d}\)（通常可以是 \( A \) 和 \( B \) 中心之间的向量，例如 \(\mathbf{c}_A - \mathbf{c}_B\)，其中 \(\mathbf{c}_A\) 和 \(\mathbf{c}_B\) 是 \( A \) 和 \( B \) 的中心）。
- 计算初始支撑点：
  $$
  \mathbf{p} = s_{A-B}(\mathbf{d}) = s_A(\mathbf{d}) - s_B(-\mathbf{d})
  $$
- 将 \(\mathbf{p}\) 加入单纯形，单纯形现在是一个点（0-simplex）。

### 2. 迭代
- **检查原点是否在当前单纯形内**：
  - 如果单纯形是一个点：检查点是否为原点（通常不可能）。
  - 如果单纯形是一条线段：检查原点是否在线段上，或者找到离原点最近的点。
  - 如果单纯形是一个三角形（2D）或四面体（3D）：检查原点是否在内部，或者找到离原点最近的点。
- **计算新的搜索方向**：
  - 使用当前单纯形找到离原点最近的点（记为 \(\mathbf{v}\)）。
  - 如果 \(\mathbf{v} = \mathbf{0}\)，则原点在单纯形内，碰撞发生，算法终止。
  - 否则，新的搜索方向为：
    $$
    \mathbf{d} = -\mathbf{v}
    $$
    即指向原点的方向。
- **更新单纯形**：
  - 计算新的支撑点：
    $$
    \mathbf{p} = s_{A-B}(\mathbf{d})
    $$
  - 检查是否可以在当前方向上更接近原点：
    - 如果 \(\mathbf{p} \cdot \mathbf{d} \leq \mathbf{v} \cdot \mathbf{d}\)，说明无法更接近原点，算法终止（无碰撞）。
    - 否则，将 \(\mathbf{p}\) 加入单纯形，并移除不必要的点（保持单纯形尽可能小）。
- **调整单纯形**：
  - 根据当前维度（2D 或 3D），单纯形最多有 3 个点（2D）或 4 个点（3D）。
  - 移除那些对包含原点无贡献的点（例如，通过检查哪些点在离原点最近的子单纯形之外）。

### 3. 终止条件
- 如果单纯形包含原点，则 \( A \) 和 \( B \) 相交。
- 如果无法通过添加新点更接近原点，则 \( A \) 和 \( B \) 不相交。

## 5. 3D 具体实现要点

在 3D 空间中，GJK 算法需要处理以下情况：

- **0-simplex（一个点）**：
  - 如果点是原点，碰撞发生。
  - 否则，方向 \(\mathbf{d} = -\mathbf{p}\)。
- **1-simplex（一条线段）**：
  - 找到线段上离原点最近的点（可以通过参数化表示 \(\mathbf{p}_0 + t (\mathbf{p}_1 - \mathbf{p}_0)\)，计算 \( t \)）。
  - 如果最近点是原点，碰撞发生。
  - 否则，方向 \(\mathbf{d} = -\mathbf{v}\)，并保留最近点所在的子单纯形（可能是线段的一个端点或整条线段）。
- **2-simplex（一个三角形）**：
  - 找到三角形上离原点最近的点（需要计算重心坐标或投影）。
  - 如果最近点是原点，碰撞发生。
  - 否则，方向 \(\mathbf{d} = -\mathbf{v}\)，保留最近点所在的子单纯形（可能是三角形的一个边、一个顶点）。
- **3-simplex（一个四面体）**：
  - 检查原点是否在四面体内（可以通过检查原点是否在四面体的每个面法线内侧）。
  - 如果原点在四面体内，碰撞发生。
  - 否则，找到离原点最近的点（可能是四面体的一个面、边或顶点），更新方向 \(\mathbf{d} = -\mathbf{v}\)，并保留相应的子单纯形。

## 6. 扩展：EPA 算法

GJK 算法只能判断是否碰撞。如果需要计算穿透深度和碰撞法线，可以使用 **EPA 算法**（Expanding Polytope Algorithm）：

### 原理
- 如果 GJK 确定碰撞发生，当前单纯形（通常是一个四面体）已经包含原点。
- EPA 算法从这个单纯形开始，逐步扩展多面体（polytope），直到找到离 \( A - B \) 表面最近的点。
- 这个最近点到原点的距离即为穿透深度，方向即为碰撞法线。

### 步骤
1. 从 GJK 的最终单纯形开始。
2. 找到多面体上离原点最近的面。
3. 在该面法线方向上计算新的支撑点，扩展多面体。
4. 重复直到找到最小穿透深度。

## 7. 优点与局限性

### 优点
- **高效**：无需计算整个 Minkowski 差，仅通过支撑函数操作。
- **通用**：适用于任何凸形状（只要能提供支撑函数）。
- **可扩展**：可以与 EPA 结合计算穿透深度和法线。

### 局限性
- 只适用于凸形状（非凸形状需要分解为多个凸形状）。
- 数值精度问题：在某些边界情况下（例如非常接近的碰撞），可能需要额外的精度处理。
- 实现复杂度：需要处理 3D 空间中的几何计算（例如点到三角形的最近点）。

## GJK 在当前项目中的应用

### 场景
- 项目中有球体和凸包（立方体），GJK 可以处理：
  - 球体-球体
  - 球体-凸包
  - 凸包-凸包 的碰撞。

### 支持函数实现
- **球体**：支撑点是球心加上沿方向 \(\mathbf{d}\) 缩放的半径向量。
- **凸包**：遍历所有顶点，找到沿 \(\mathbf{d}\) 方向最远的顶点。

### 碰撞响应
- 当前使用冲量法，可以直接使用 GJK 的结果（是否碰撞）。
- 未来可以引入 EPA 获取穿透深度和法线，提升碰撞响应精度。




---

# EPA 算法原理详解（Expanding Polytope Algorithm）

EPA 算法是 GJK 算法的扩展，旨在在 GJK 检测到两个凸形状 \( A \) 和 \( B \) 发生碰撞后，进一步计算碰撞的**穿透深度**和**碰撞法线**。这些信息对于实现精确的碰撞响应（例如分离物体或计算冲量）至关重要。EPA 算法通过逐步扩展 Minkowski 差 \( A - B \) 的多面体，找到离原点最近的点，从而得出穿透深度和法线。

---

## 1. 基本概念

### 1.1 Minkowski 差回顾
GJK 算法基于 Minkowski 差 \( A - B \)，定义为：
$$
A - B = \{ \mathbf{a} - \mathbf{b} \mid \mathbf{a} \in A, \mathbf{b} \in B \}
$$
当 \( A \) 和 \( B \) 相交时，原点 \(\mathbf{0}\) 位于 \( A - B \) 内部。EPA 算法利用这个特性，从 GJK 返回的包含原点的单纯形开始，扩展多面体以逼近 \( A - B \) 的边界。

### 1.2 穿透深度和法线
- **穿透深度**：\( A \) 和 \( B \) 重叠部分的“厚度”，即 \( A - B \) 的边界到原点的最短距离。
- **碰撞法线**：从原点指向 \( A - B \) 边界最近点的方向，表示碰撞的接触面法线。

EPA 的目标是通过迭代找到 \( A - B \) 上离原点最近的点 \(\mathbf{p}\)，其中：
- 穿透深度 \( d = \|\mathbf{p}\|
- 法线 \(\mathbf{n} = \frac{\mathbf{p}}{\|\mathbf{p}\|}\)

---

## 2. 算法原理

EPA 算法的核心思想是从 GJK 提供的初始单纯形（通常是四面体）开始，构造一个多面体（polytope），然后通过以下步骤逐步逼近 \( A - B \) 的边界：

### 2.1 初始多面体
- GJK 算法在检测到碰撞时，通常返回一个包含原点的四面体（4 个顶点）。
- 这些顶点是 Minkowski 差 \( A - B \) 的样本点，可以用它们构建初始多面体。
- 初始多面体的每个面是一个三角形，法线朝向原点（确保 \( A - B \) 的内部包含原点）。

### 2.2 最近面搜索
- 对于当前多面体，计算每个面到原点的距离。
- 距离定义为：面上的一个点 \(\mathbf{v}\) 到原点的投影长度，公式为：
  $$
  d = |\mathbf{n} \cdot \mathbf{v}|
  $$
  其中 \(\mathbf{n}\) 是面的法线，\(\mathbf{v}\) 是面上的任意点。
- 找到距离最小的面（最近面），其法线方向将成为下一次搜索的方向。

### 2.3 多面体扩展
- 在最近面的法线方向 \(\mathbf{n}\) 上，计算 Minkowski 差的支撑点：
  $$
  \mathbf{p} = s_{A-B}(\mathbf{n}) = s_A(\mathbf{n}) - s_B(-\mathbf{n})
  $$
- 如果 \(\mathbf{p}\) 的投影距离 \( \mathbf{n} \cdot \mathbf{p} \) 与最近面距离的差值小于阈值，则认为多面体已足够接近边界，停止迭代。
- 否则，将 \(\mathbf{p}\) 添加到多面体顶点列表中。

### 2.4 面更新
- 检查所有现有面，判断哪些面被新点 \(\mathbf{p}\)“看到”（即 \(\mathbf{p}\) 在面的法线方向上）。
- 移除可见面，收集其边界边。
- 使用这些边和新点 \(\mathbf{p}\) 创建新的三角形面，更新多面体。

### 2.5 收敛条件
- 当新支撑点的投影距离变化小于某个阈值（例如 \( 0.0001 \)）时，停止迭代。
- 或者达到最大迭代次数（例如 64 次）以防止无限循环。
- 最终，最近面的距离即为穿透深度，法线即为碰撞法线。

---

## 3. 算法步骤

### 3.1 输入
- GJK 返回的初始单纯形（通常是 4 个顶点的四面体）。
- 两个碰撞体的碰撞器 \( A \) 和 \( B \)，以及它们的位移 \(\mathbf{posA}\) 和 \(\mathbf{posB}\)。

### 3.2 详细步骤
1. **初始化多面体**：
   - 从 GJK 的四面体顶点 \(\mathbf{v}_0, \mathbf{v}_1, \mathbf{v}_2, \mathbf{v}_3\) 开始。
   - 构建初始面列表，例如 \(\triangle v_0v_1v_2, \triangle v_0v_3v_1, \triangle v_0v_2v_3, \triangle v_1v_3v_2\)。
   - 为每个面计算法线 \(\mathbf{n} = \frac{\mathbf{v}_1 - \mathbf{v}_0 \times \mathbf{v}_2 - \mathbf{v}_0}{\|\mathbf{v}_1 - \mathbf{v}_0 \times \mathbf{v}_2 - \mathbf{v}_0\|}\)，并确保法线指向原点（调整符号）。

2. **迭代过程**：
   - 计算每个面的距离 \( d = \min(|\mathbf{n} \cdot \mathbf{v}|) \)，其中 \(\mathbf{v}\) 是面上的顶点。
   - 选择距离最小的面，法线 \(\mathbf{n}\) 作为搜索方向。
   - 计算新支撑点 \(\mathbf{p} = s_{A-B}(\mathbf{n})\)。
   - 如果 \( |\mathbf{n} \cdot \mathbf{p} - d| < \epsilon \)（\(\epsilon\) 为阈值），则：
     - 穿透深度 \( d = |\mathbf{n} \cdot \mathbf{p}| \)
     - 法线 \(\mathbf{n} = \frac{\mathbf{n}}{\|\mathbf{n}\|}\)
     - 退出。
   - 否则，将 \(\mathbf{p}\) 添加到顶点列表。

3. **面更新**：
   - 对于每个面，计算 \(\mathbf{n} \cdot \mathbf{p} - d\)：
     - 如果大于 0，则该面可见，移除该面。
     - 收集可见面的所有边（\(\{i, j\}\) 配对）。
   - 使用边和新顶点索引创建新面，例如 \(\triangle i j p\)。

4. **重复**：
   - 重复步骤 2 和 3，直到收敛或达到最大迭代次数。

### 3.3 输出
- **穿透深度**：最近面到原点的距离 \( d \)。
- **碰撞法线**：最近面的法线 \(\mathbf{n}\)。

---

## 4. 数学推导

### 4.1 距离计算
对于一个面，假设顶点为 \(\mathbf{v}_0, \mathbf{v}_1, \mathbf{v}_2\)，法线为 \(\mathbf{n}\)，距离 \( d \) 可以表示为：
$$
d = \min_{\mathbf{v} \in \text{face}} |\mathbf{n} \cdot \mathbf{v}|
$$
实际中，取面上的一个点（如 \(\mathbf{v}_0\)）的投影距离：
$$
d = |\mathbf{n} \cdot \mathbf{v}_0|
$$
法线的方向需调整，确保 \( d \geq 0 \)（朝向原点）。

### 4.2 新点投影
新支撑点 \(\mathbf{p}\) 的投影距离为：
$$
d_{\text{new}} = \mathbf{n} \cdot \mathbf{p}
$$
收敛条件为 \( |d_{\text{new}} - d| < \epsilon \)。

### 4.3 面可见性
一个面可见的条件是新点 \(\mathbf{p}\) 在其法线方向上，即：
$$
\mathbf{n} \cdot (\mathbf{p} - \mathbf{v}) > 0
$$
其中 \(\mathbf{v}\) 是面上的任意点。

---

## 5. 实现中的注意事项

### 5.1 数值稳定性
- EPA 依赖于浮点运算，可能会因精度问题导致振荡或错误收敛。
- 使用小的 \(\epsilon\)（例如 \( 0.0001 \)）作为阈值，平衡精度和性能。
- 最大迭代次数（例如 64）防止无限循环。

### 5.2 初始条件
- GJK 必须返回一个包含原点的四面体，否则 EPA 无法工作。
- 如果初始单纯形不是四面体，需扩展 GJK 以确保生成四面体。

### 5.3 性能优化
- 使用 `std::set` 存储边，避免重复。
- 减少不必要的法线重新计算（仅在创建新面时计算）。

---

## 6. 在项目中的应用

### 6.1 场景
- 当前项目中，EPA 将用于球体-球体、球体-凸包、凸包-凸包的碰撞。
- 穿透深度和法线将替换之前的固定值（0.1f），提高碰撞响应的精度。

### 6.2 实现细节
- **支持函数**：沿用 GJK 的 `support` 函数。
- **多面体管理**：使用 `std::vector` 存储顶点，使用自定义 `PolytopeFace` 结构存储面。
- **输出**：返回 `penetration`（浮点数）和 `normal`（单位向量）。

### 6.3 碰撞响应
- 使用 EPA 的穿透深度调整物体位置：
  $$
  \Delta \mathbf{p}_1 = -\mathbf{n} \cdot \frac{d}{2}, \quad \Delta \mathbf{p}_2 = \mathbf{n} \cdot \frac{d}{2}
  $$
- 使用法线计算冲量：
  $$
  \mathbf{j} = -(1 + e) \frac{\mathbf{v}_{\text{rel}} \cdot \mathbf{n}}{\frac{1}{m_1} + \frac{1}{m_2}} \mathbf{n}
  $$
  其中 \( e \) 为恢复系数，\(\mathbf{v}_{\text{rel}}\) 为相对速度。

---

## 7. 优点与局限性

### 优点
- **精确性**：提供真实的穿透深度和法线，提升碰撞响应质量。
- **通用性**：适用于任何凸形状，与 GJK 兼容。
- **扩展性**：可与 GJK 结合，形成完整的窄阶段解决方案。

### 局限性
- **计算复杂度**：比 GJK 更高，尤其是在复杂多面体中。
- **数值问题**：可能因浮点精度导致不稳定。
- **依赖 GJK**：需 GJK 提供正确初始条件。

---
